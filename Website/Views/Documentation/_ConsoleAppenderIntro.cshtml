@using ViewExtensions

@{
    bool showWebConfigCode =
        ((string)(ViewData["configSource"]) == "web.config");

    string currentVersion = PageVersions.CurrentVersion();
}

<p>
    The ConsoleAppender sends log messages to <span class="term">console.log</span>.
</p>

@if (currentVersion == "NodeJs")
{
    <p>
        On the server, jsnlog.js by default logs via the ConsoleAppender.
        And on the client, by default it uses the
        @Html.ViewLink("jsnlogjs-ajaxappender")<text>.</text>
    </p>
}
else
{
    <p>
        JSNLog is based on the idea of integrating client side and server side logging - using the
        @if (showWebConfigCode)
        {
            @Html.ViewLink("webconfig-ajaxappender", "AjaxAppender")
        }
        else
        {
            @Html.ViewLink("jsnlogjs-ajaxappender")
        }
        to send log items to the server.
    </p>
}
<p>
    However, during development
    @if (currentVersion == "NodeJs")
    {
        <text>on the client</text>
    }

    it can be useful to simply send log items to the
    browser console provided by the F12 developer tools in
    <a href="https://developers.google.com/chrome-developer-tools/docs/console" target="_blank">Chrome</a>,
    <a href="http://getfirebug.com/" target="_blank">Firefox</a>
    and
    <a href="" target="_blank">Internet Explorer</a>.
</p>
<p>
    That way, the log items appear immediately below your main browser window, so you don't have to check the server side log.
</p>

<h3>Trace and Debug messages filtered out by default</h3>
<p>
    Chrome allows you to filter log messages by severity before they appear in the <span class="term">Console</span> tab. 
    By default, the lowest severity, <span class="term">Verbose</span>, is disabled.
    Because JSNLog maps Trace and Debug messages to this 
     <span class="term">Verbose</span>
    level, Trace and Debug messages do not show up by default in the Chrome <span class="term">Console</span> tab.
</p>
<p>
    To solve this, in the Chrome debugger, 
    in the <span class="term">Console</span> tab, 
    change the dropdown from <span class="term">Info</span> to <span class="term">Verbose</span>:
</p>
<img src="~/Images/ChromeSeverityDropdown.png" width="475" height="77" />

<h3>Sending log items from a JavaScript logger to the console</h3>
<p>
    To see the log items that are generated by a logger in the console, you first create a ConsoleAppender and then 
    @if (showWebConfigCode)
    {
        @Html.ViewLink("webconfig-logger", "configure the logger")
    }
    else
    {
        <text>use the</text>
        @Html.ViewLink("jsnlogjs-logger-setOptions", "setOptions Method")
        <text>of the logger</text>
}
     to
    send all log items to that ConsoleAppender:
</p>

@if (showWebConfigCode)
{
@Html.Partial(@"Demos/_consoleappender1")
}
else
{
<pre>// "mylogger" logs to just the console
var consoleAppender=JL.createConsoleAppender('consoleAppender');
JL("mylogger").setOptions({"appenders": [consoleAppender]});
</pre>
}
<p>
    However, this means that all log items will only go to the console, and no longer to the server.
    If you want the log items to go to both the console and the server,
    send them to an AjaxAppender as well as to a ConsoleAppender:
</p>

@if (showWebConfigCode)
{
@Html.Partial(@"Demos/_consoleappender2")
}
else
{
<pre>// "mylogger" logs to both the server and the console
var ajaxAppender=JL.createAjaxAppender('ajaxAppender');
var consoleAppender=JL.createConsoleAppender('consoleAppender');
JL("mylogger").setOptions({"appenders": [ajaxAppender,consoleAppender]});
</pre>
}

<h3>Sending log items from every logger to both the console and the server</h3>
<p>
    It may be easiest to get all loggers to log to both the console and the server.
    You can achieve this by 
    @if (showWebConfigCode)
    {
        @Html.ViewLink("webconfig-logger", "configuring the root logger")<text>.</text>
}
else
{
        <text>using the</text>
        @Html.ViewLink("jsnlogjs-logger-setOptions", "setOptions Method")
        <text>of the root logger.</text>
}
    
    Through
    @if (showWebConfigCode)
    {
        @Html.ViewLink("webconfig-logger", "inheritance", fragment: "inheritance")<text>,</text>
    }
    else
    {
        @Html.ViewLink("jsnlogjs-logger-setOptions", "inheritance", fragment: "inheritance")<text>,</text>
    }
    every other JavaScript logger will start logging to both the console and the server as well.
</p>

@if (showWebConfigCode)
{
@Html.Partial(@"Demos/_consoleappender3")
}
else
{
<pre>// Debugging: all loggers log to both the server and the console
var ajaxAppender=JL.createAjaxAppender('ajaxAppender');
var consoleAppender=JL.createConsoleAppender('consoleAppender');
JL().setOptions({"appenders": [ajaxAppender,consoleAppender]});
</pre>
}

<h3>Switching off logging to the console</h3>
<p>
    Once in production, you may want to stop logging to the console.
    You can achieve this by removing the ConsoleAppender:
</p>

@if (showWebConfigCode)
{
@Html.Partial(@"Demos/_consoleappender4")
}
else
{
<pre>// Production: loggers log to the server only
var ajaxAppender=JL.createAjaxAppender('ajaxAppender');
JL().setOptions({"appenders": [ajaxAppender]});
</pre>
}
<p>
    This means you don't have to go through your code to remove logging code - a simple change in
    @if (showWebConfigCode)
    {
        <text>the web.config</text>
    }
    else
    {
        <text>one place</text>
    }
    is enough. Keep in mind that if you associate individual JavaScript loggers with the ConsoleAppender,
    you will have to remove that as well in order to stop all logging to the console.
</p>


