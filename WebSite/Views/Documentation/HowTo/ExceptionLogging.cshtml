@using ViewExtensions

@{
    ViewBag.Title = "Logging JavaScript Exceptions";
    ViewBag.Key = "getstarted-exceptionLogging";
    ViewBag.Description = "Logging JavaScript exceptions with JSNLog.";
    Layout = "~/Views/Shared/_DocumentationLayout.cshtml";

    var currentVersion = PageVersions.CurrentVersion();
}

<p>
    JSNLog makes it very easy to log
    @if (currentVersion == "NodeJs")
    {
        <text>client side</text>
    }

    JavaScript exceptions to your server side log. To do this, you can either use
    the window.onerror handler or a <a href="#trycatch">try-catch block</a>.
</p>

<a id="onerror"></a>
<h2>window.onerror</h2>
<p>
    The
    <a target="_blank" href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#errorevent">window.onerror</a>
    handler lets you handle any exceptions that haven't been caught elsewhere in your code.
    The JavaScript interpreter will pass your handler an error message, the url of the file where the javascript exception happened, and the line number.
    On more modern browsers, you get the column number and exception as well.
</p>

<h3>JSNLog sets a handler for uncaught exceptions</h3>

<p>
    When it loads, the jsnlog.js library checks if <span class="term">window.onerror</span> has been set. If it isn't, it 
    sets a handler that logs the uncaught exception to your server side log:
</p>

<pre>
// Code included in jsnlog.js to set a handler that logs uncaught exceptions to 
// the server side log.

if (window && !window.onerror) {
    window.onerror = function (errorMsg, url, lineNumber, column, errorObj) {
        JL("onerrorLogger").fatalException({
            "msg": "Uncaught Exception",
            "errorMsg": errorMsg, "url": url,
            "line number": lineNumber, "column": column
        }, errorObj);

        return false;
    }
}</pre>

<p>
    Looking at this code, you'll see that the browser is supposed to pass 
    5 parameters to the onerror handler.
    Unfortunately, not all browsers pass in all parameters.
</p>
<p>
    If there is an exception on a browser that doesn't support all 5 parameters, the missing parameters are left undefined.
    In that case, JSNLog will simply only send the parameters that it did get. This way, when more browsers start supporting
    the full set of parameters, you will get all the available information.
</p>
<p>
    You'll also notice that this code returns false. This tells the 
    browser to do its own error handling in addition to the handler - so it will write a message to the console, etc.
    Returning true would have told the browser that the error has been completedly handled and it doesn't need to do anything. 
</p>

<h3>How to set your own handler for uncaught exceptions</h3>

<p>
    To override JSNLog's handler, simply set <span class="term">window.onerror</span> to your own handler.
</p>
<p>
    If your code runs before jsnlog.js loads, jsnlog.js will see that 
    <span class="term">window.onerror</span> has already been set and leave it alone. If your code runs after 
    jsnlog.js loads, your code will overwrite <span class="term">window.onerror</span>.
</p>

<h3>How to prevent logging of uncaught exceptions</h3>

<p>
    If you do not want to log uncaught JavaScript exceptions at all, set <span class="term">window.onerror</span>
    to a method that does nothing:
</p>

<pre>window.onerror = function (errorMsg, url, lineNumber, column, errorObj) {
    return false;
}</pre>


<a id="trycatch"></a>
<h2>Try Catch</h2>
<p>
    As you saw, using a <span class="term">window.onerror</span> handler is convenient, 
    because you only need to set it once to catch all exceptions. But it doesn't always give you
    the column number or stack trace of the exception, making it harder to fix the exception.
</p>

<p>
    A solution to this is to put your code in try-catch blocks, like this:
</p>

<pre>try {
    ...
    // ReferenceError: xyz is not defined
    xyz;
    ...
} catch (e) {
    // Log the exception
    JL().fatalException("something went wrong!", e);
    
    // Rethrow the exception, so the browser 
    // doesn't forget about this error situaion.
    throw e
}
</pre>
<p>
    In
    @Html.ViewLink("jsnlogjs-logger-fatalException", "most", null, "Remarks")
    cases, JSNLog will log not only the message and basic exception details, but the stack trace as well.
</p>

<h2>More information, but only when you need it</h2>
<p>
    Often you need more information than provided in the exception to track down the cause of the JavaScript exception.
    You might wind up logging debug information in various places in your JavaScript:
</p>

<pre>
function f1(a, b) {
    JL("f1").debug({"a": a, "b": b});
    ...
}
&nbsp;
function f2(c, d) {
    JL("f2").debug({"c": c, "d": d});
    ...
}
&nbsp;
function f3() {
    try {
        ...
    } catch(e) {
        JL().fatalException("message", e);
        throw e;
    }
}
</pre>
<p>
    The problem is that now you'll be receiving lots of debug messages, even if there is no exception.
    You do want the debug messages, but only if there is a JavaScript exception.
</p>
<p>
    The solution is to have JSNLog store the debug messages in browser memory, and only send them when there is a fatal message.
</p>


@if (currentVersion == "NetJs")
{
    <p>
        To make that happen, you can configure your loggers like so
        <text>(</text>@Html.ViewLink("webconfig-ajaxappender", "details", null, "Remarks")<text>)</text>:
    </p>

@Html.Partial(@"Demos/_exceptions1")

    <p>
        This creates an
        @Html.ViewLink("webconfig-ajaxappender", "AjaxAppender")<text>,</text>
        the component that actually sends log messages to the server. Here it is configured to
        store the last 20 log messages with severity DEBUG or higher in browser memory. When there is a log message with severity FATAL,
        both the fatal message itself and the stored messages are sent to the server. If there is no fatal message, nothing is sent to the server.
    </p>
}

@if ((currentVersion == "JsOnly") || (currentVersion == "NodeJs"))
{
    <p>
        To make that happen, you can configure your loggers in your JavaScript like so
        <text>(</text>@Html.ViewLink("jsnlogjs-ajaxappender-setOptions", "details", null, "Remarks")<text>)</text>:
    </p>

<pre>var appender = JL.createAjaxAppender("appender");
appender.setOptions({
    "bufferSize": 20,
    "storeInBufferLevel": JL.getDebugLevel(),
    "level": JL.getFatalLevel(),
    "sendWithBufferLevel": JL.getFatalLevel()
});
JL().setOptions({ "appenders": [appender] });</pre>


    <p>
        This creates an
        @Html.ViewLink("jsnlogjs-ajaxappender", "AJAX Appender")<text>,</text>
        the component that actually sends log messages to the server. Here it is configured to
        store the last 20 log messages with severity DEBUG or higher in browser memory. When there is a log message with severity FATAL,
        both the fatal message itself and the stored messages are sent to the server. If there is no fatal message, nothing is sent to the server.
    </p>
}

<p>
    The last line associates the root logger with the new appender.
    Because all loggers inherit from the root logger, they will now all send their messages through the new AJAX Appender.
</p>



<h2>More about logging JavaScript exceptions</h2>
<ul>
    <li>
        @Html.ViewLink("jsnlogjs-logger-fatalException")
    </li>
    <li>
        @Html.ViewLink("jsnlogjs-exception")
    </li>
</ul>

